---
title: HAProxy Starter Guide翻译
date: 2018-12-02 23:45:17
tags: [HAProxy,翻译]
---

根据[官方18.14文档Starter Guide](https://cbonte.github.io/haproxy-dconv/1.8/intro.html)的翻译，并非完整翻译，且有的地方会有修改。

<!--more-->

* [快速介绍负载均衡和负载均衡器]()
* [HAProxy介绍]()
  * [HAProxy是什么与不是什么]()
  * [HAProxy如何工作]()
  * [基本功能]()
    * [代理]()
    * [SSL]()
    * [监控]()
    * [高可用]()
    * [负载均衡]()
    * [粘性]()
    * [采样和转换信息]()
    * [映射]()
    * [ACL和条件]()
    * [内容转换]()
    * []()
    * []()
    * []()
    * 







# 快速介绍负载均衡和负载均衡器

负载均衡包括聚合多个组件，以便在每个组件的单独流量上实现总处理能力，而无需客户端用户的任何干预并且是可扩展的。这导致组件在仅执行一个操作所花费的时间内同时执行更多操作。 但是，单个操作仍然会一次在单个组件上执行，并且不会比没有负载均衡时更快。 它始终需要至少与可用组件一样多的操作和有效的负载均衡机制来充分利用所有组件并从负载均衡中充分受益。一个很好的例子是高速公路上的车道数量，不增加车辆速度而允许尽可能多的车辆在同一时间段内通过。

负载均衡的示例：

* 多处理器系统中的进程调度
* 链路负载均衡（例如EtherChannel，Bonding）
* IP地址负载均衡（例如ECMP，DNS round-robin）
* 服务器负载均衡（通过负载均衡器）

执行负载均衡操作的机制或组件称为负载均衡器。 在Web环境中，这些组件称为“网络负载均衡器”，更常见的是“负载均衡器”，因为此说法是迄今为止负载均衡的最好示例。

负载均衡器可以起作用：

* 在链路级别：这称为链路负载均衡，它包括选择发送数据包的网络链路
* 在网络级别：这称为网络负载均衡，它包括选择一系列数据包将使用的路由
* 在服务器级别：这称为服务器负载均衡，它包括决定哪个服务器将处理连接或请求

存在两种不同的技术并满足不同的需求，但有一些重叠。在每种情况下，重要的是要记住，负载均衡包括将流量从其自然流转移，并且这样做总是需要最少的维护，以维持所有路由决策之间所需的一致性水平。

第一个技术作用于数据包级别并且或多或少地单独处理数据包。 输入和输出数据包之间存在一对一的关系，因此可以使用常规网络嗅探器跟踪负载均衡器两侧的流量。这项技术非常便宜且速度极快。 它通常以硬件（ASIC）实现，能够达到线速（line rate），例如执行ECMP的交换机。 通常是无状态的，它也可以是有状态的（考虑一个数据包所属的会话并称为layer4-LB或L4），如果数据包没有被修改，可以支持DSR（直接服务器返回，不再通过LB），但几乎不提供内容感知（content awareness）。 该技术非常适合网络级负载均衡，但有时用于高速的基本服务器负载均衡。

第二个技术作用于会话内容。 它要求输入流作为一个整体进行重组和处理。 可以修改内容，并且将输出流分段为新分组。出于这个原因，它通常由代理执行，它们通常被称为第7层负载均衡器或L7。这意味着每一侧有两个不同的连接，并且输入和输出数据包大小与计数之间没有关系。客户端和服务器不需要使用相同的协议（例如IPv4与IPv6，不加密与SSL）。 操作始终是有状态的，返回流量必须通过负载均衡器。 额外的处理带来了成本，因此并不总是能够实现线速，特别是对于小数据包。 另一方面，它提供了广泛的可能性，并且通常通过纯软件实现，即使嵌入到硬件设备中也是如此。 该技术非常适合服务器负载均衡。

基于数据包的负载均衡器通常以直通模式（cut-though mode）部署，因此它们安装在流量的正常路径上，并根据配置进行转移。 返回的流量不一定通过负载均衡器。 可以对网络目的地址进行一些修改，以便将流量引导到适当的目的地。 在这种情况下，返回流量必须通过负载均衡器。如果路由不能实现这一点，则负载均衡器也可以用自己的路由替换数据包的源地址，强制返回流量通过它。

基于代理的负载均衡器部署为具有自己的IP地址和端口的服务器，无需更改体系结构。 
有时，这需要对应用程序执行一些调整，以便客户端正确定向到负载均衡器的IP地址，而不是直接定向到服务器。某些负载均衡器可能必须调整某些服务器的响应才能实现这一点（例如HTTP重定向中使用的HTTP Location头字段）。某些基于代理的负载均衡器可能会拦截其不拥有的地址的流量，并在连接到服务器时欺骗客户端的地址。这使得它们可以像通常的路由器或防火墙一样进行部署，采用与基于数据包的负载均衡器非常相似的直通模式。对于结合了分组模式和代理模式的产品，这是特别受欢迎的。 在这种情况下，DSR显然仍然不可能，并且返回流量仍然必须路由回负载均衡器。

一种非常可扩展的分层方法将包括具有从多个负载均衡链路接收流量的前端路由器，并使用ECMP将该流量分配到多个有状态分组的负载均衡器（L4）的第一层。这些L4负载均衡器又将流量传递给更大数量的基于代理的负载均衡器（L7），这些负载均衡器必须解析内容以确定哪个服务器最终将接收流量。

流量的组件数量和可能的路径增加了失败的风险; 在非常大的环境中，永久性地将一些故障部件修复或替换是正常的。 在不了解整个堆栈的运行状况的情况下完成负载均衡会显着降低可用性。 出于这个原因，任何严谨的负载均衡器都将验证它打算提供流量的组件是否仍然存活且可访问，并且它将停止向故障流量提供流量。 这可以使用各种方法实现。

最常见的一种是定期发送探测包以确保组件仍可运行。 这些探测包称为“健康检查”。 它们必须代表要解决的失败类型。 例如，基于ping的检查不会检测到Web服务器已经崩溃并且不再监听端口，而与端口的连接将验证这一点，而更高级的请求甚至可以验证服务器是否仍然有效并且它依赖的数据库仍然可以访问。 健康检查通常需要进行一些重试以防止偶尔的监测错误。检查之间的时间间隔必须足够小，以确保在发生错误后故障组件的使用时间不会太长。

其他方法包括对发送到目的地的生产流量进行抽样，以观察是否正确处理，并去除返回不适当响应的组件。 然而，这需要牺牲一部分生产流量，这并不总是可以接受的。 这两种机制的组合提供了两全其美的优势，两者都用于检测故障，只有健康检查才能检测到故障的结束。 最后一种方法涉及集中报告：中央监控代理定期更新所有负载均衡器的所有组件的状态。 这为所有组件提供了基础架构的全局视图，但有时精度或响应性较低。 它最适合具有许多负载均衡器和许多服务器的环境。

第7层负载均衡器还面临另一个被称为粘性或持久性的挑战。 原则是它们通常必须将来自同一来源（例如最终用户）的多个后续请求或连接指向同一目标。 最着名的例子是在线商店的购物车。 如果每次点击都会导致新连接，则必须始终将用户发送到保存其购物车的服务器。 内容感知使得更容易发现请求中的某些元素以识别要将其传递到的服务器，但这并不总是足够的。 例如，如果把源地址用作选择服务器的指标，则可以确定将使用基于散列的算法，并且将始终按可用服务器的数量基于地址划分将给定的IP地址发送到同一服务器 。 但是如果一台服务器出现故障，结果会发生变化，所有用户都会突然被发送到另一台服务器并丢失购物车。 针对此问题的解决方案在于记录所选目标，以便每次看到相同的访问者时，无论可用服务器的数量如何，都会将其定向到同一服务器。 信息可以存储在负载均衡器的内存中，在这种情况下，如果不是单独的话，可能必须将其复制到其他负载均衡器，或者可以使用各种方法存储在客户端的内存中，前提是客户端能够随每个请求呈现该信息（cookie插入，重定向到子域等）。 这种机制提供了额外的好处，即不必依赖不稳定或分布不均匀的信息（例如源IP地址）。 事实上，这是采用第7层负载均衡器而不是第4层负载均衡器的最有力理由。

为了提取诸如cookie，主机头字段，URL或其他信息之类的信息，负载均衡器可能需要解密SSL/TLS流量，甚至可能在将其传递给服务器时对其进行重新加密。 这个复杂的任务解释了为什么在一些高流量的基础设施中，有时可能会有很多负载均衡器。 
由于第7层负载均衡器可以对流量执行许多复杂的操作（解密，解析，修改，匹配cookie，决定要发送到哪个服务器等），它肯定会造成一些麻烦，并且通常会为显露出很多麻烦而被指责。 通常会发现服务器不稳定并且周期性地停止重启，或者对于Web服务器，它们会传递带有一些硬编码链接的页面，迫使客户端直接连接到一个特定的服务器而不通过负载均衡器，或者他们需要很长时间才能在高负荷下做出反应，导致超时，这就是为什么日志记录是第7层负载均衡的一个极其重要的方面。一旦报告故障，重要的是要确定负载均衡器是否做出了错误的决定，如果是这样，如何才能不再发生这种情况。



# HAProxy介绍

HAProxy写作“HAProxy”来指定产品，而“haproxy”被指定为可执行程序，软件包或进程。 然而，两者通常用于两种目的，并且发音为H-A-Proxy。，很早以前，“haproxy”曾经代表“高可用性代理”，这个名字用两个单独的单词写成，但现在它只不过是“HAProxy”。



## HAProxy是什么与不是什么

HAProxy是：

* TCP代理：它可以接受来自侦听套接字的TCP连接，连接到服务器并将这些套接字连接在一起，允许流量在两个方向上流动
* HTTP反向代理（在HTTP术语中称为“网关”）：它将自身表示为服务器，通过侦听TCP套接字上接受的连接接收HTTP请求，并使用不同的连接将请求从这些连接传递到服务器。
* SSL终端/发起者/卸载程序（offloader）：SSL / TLS可用于来自客户端，到服务器的连接，甚至两个连接的连接。
* TCP规范化程序（normalizer）：由于操作系统本地终止了连接，双方之间没有关系，因此无效数据包、标志组合、窗口通告（window advertisement）、序列号、不完整连接（SYN泛洪）等异常流量不会被传递到另一边。 这可以保护脆弱的TCP栈免受协议攻击，并且还允许与客户端优化连接参数，而无需修改服务器的TCP栈设置。
* HTTP规范化程序：配置为处理HTTP流量时，仅传递有效的完整请求。 这可以防止许多基于协议的攻击。 另外，规范中存在容差的协议偏差是固定的，因此它们不会在服务器上引起问题（例如，多行头）。
* HTTP修复工具：它可以修改/修复/添加/删除/重写URL或任何请求或响应头。 这有助于解决复杂环境中的互操作性（interoperability）问题。
* 基于内容的交换机：它可以根据请求中的任何元素来决定将请求或连接传递给哪个服务器。 因此，可以在同一端口上处理多个协议（例如，HTTP，HTTPS，SSH）。
* 服务器负载均衡器：它可以对TCP连接和HTTP请求进行负载均衡。 在TCP模式下，对整个连接采取负载均衡决策。 在HTTP模式下，根据请求做出决定。
* 流量调节器：它可以在不同点应用一些速率限制，保护服务器免受过载，根据内容调整流量优先级，甚至通过标记数据包将这些信息传递给较低层和外部网络组件。
* 防止DDoS和服务滥用（service abuse）：它可以维护每个IP地址，URL，cookie等的大量统计信息，并检测何时发生滥用，然后采取措施（减慢违规行为，阻止它们，将它们发送到过时的内容 等）。
* 网络故障排除的观察点：由于日志中报告的信息的精确性，它通常用于缩小网络相关问题的范围。
* HTTP压缩卸载程序：它可以压缩未被服务器压缩的响应，从而减少连接不良或使用高延迟移动网络的客户端的页面加载时间。

HAProxy不是：

* 显式HTTP代理，即浏览器用于访问互联网的代理。 有专门用于此任务的优秀开源软件，例如Squid。 但是，HAProxy可以部署在这样的代理之前，以提供负载平衡和高可用性。
* 缓存代理：它将按原样返回从服务器收到的内容，不会干扰任何缓存策略。 有很好的开源软件可以完成这项任务，比如Varnish。  HAProxy可以部署在这样的缓存之前，通过智能负载平衡提供SSL卸载和可扩展性。
* 数据清理程序：它不会修改请求体和响应体。
* Web服务器：在启动期间，它将自己隔离在chroot jail中并删除其权限，以便一旦启动它就不会执行任何单个文件系统访问。 因此，它无法转变为Web服务器。 有很好的开源软件，如Apache或Nginx，HAProxy可以部署在它们前端，以提供负载平衡和高可用性。
* 基于数据包的负载均衡器：它不会看到IP数据包也不会看到UDP数据包，也不会执行NAT甚至更少的DSR（动态源路由协议）。 这些是较低层的任务。 一些基于内核的组件（如IPVS（Linux虚拟服务器））已经很好地完成了这项工作并与HAProxy完美匹配。



## HAProxy如何工作

HAProxy是一个单线程，事件驱动的非阻塞引擎，它将非常快的I / O层与基于优先级的调度程序相结合。 由于它的设计考虑了数据转发目标，因此其架构经过优化，可以尽可能快地以尽可能少的操作移动数据。 因此，它实现了一个分层模型，在每个级别提供旁路机制（bypass mechanisms），确保数据不会达到更高级别，除非需要。 大多数处理都是在内核中执行的，HAProxy尽最大努力通过提供一些提示或者在猜测它们可以在以后分组时避免某些操作来尽可能快地帮助内核完成工作。 因此，典型数据显示，在TCP或HTTP关闭模式下，HAProxy中花费的处理时间占15％，而在内核占85％，在HTTP keep-alive模式下，HAProxy约占30％，而内核占70％。

单个进程可以运行许多代理实例。根据试验，单个进程中大到300000个不同代理的配置运行正常。 因此，通常不需要为所有实例启动多个进程。 

可以使HAProxy在多个进程上运行，但它有一些限制。 一般来说，它在HTTP关闭或TCP模式下没有意义，因为内核端不能很好地扩展一些操作，如`connect()`。 它可以很好地扩展到HTTP的keep-alive模式，但是可以通过单个进程实现的性能通常比常见的需求高出一个数量级。 但是，当用作SSL卸载器（offloader）时，它确实有意义，并且在多进程模式中很好地支持此功能。

HAProxy只需要运行haproxy可执行文件和配置文件。 对于日志记录，强烈建议使用正确配置的syslog守护程序并记录日志轮换。 在启动之前解析配置文件，然后HAProxy尝试绑定所有侦听套接字，并在任何失败时拒绝启动。做到这一点，它就不会运行失败了。 这意味着没有运行时故障，如果它接受启动，它将一直有效，直到它停止。

一旦HAProxy被启动，它会做三件事：

* 处理传入的连接
* 定期检查服务器状态(称为健康检查)
* 与其他haproxy节点交换信息

处理传入连接是迄今为止最复杂的任务，因为它依赖于许多配置可能性，但它可以概括为以下9个步骤：

1. 接受来自属于称为`frontend`的配置实体的侦听套接字的传入连接 ，引用一个或多个侦听地址
2. 将特定于frontend的处理规则应用于这些可能导致阻塞它们，修改某些头或拦截它们以执行某些内部小程序（例如统计页面或CLI）的连接
3. 将这些传入连接传递给另一个表示称为`backend`的服务器池的配置实体，该服务器场包含服务器列表和此服务器池的负载平衡策略
4. 将特定于后端的处理规则应用于这些连接
5. 根据负载均衡策略决定将连接转发到哪个服务器
6. 将特定于后端的处理规则应用于响应数据
7. 将特定于前端的处理规则应用于响应数据
8. 发出日志详细报告发生的事情
9. 在HTTP中，循环回第二步以等待新请求，否则关闭连接

前端和后端有时被认为是半代理，因为它们只看端到端连接的一侧。前端只关心客户端，而后端只关心服务器。  HAProxy还支持完全代理，它们正是前端和后端的联合。 当需要HTTP处理时，配置通常会分为前端和后端，因为它们会打开很多可能性，因为任何前端都可以将连接传递给任何后端。 对于仅使用TCP的代理，使用前端和后端很少提供好处，并且使用完整代理可以使配置更具可读性。



















































































































































