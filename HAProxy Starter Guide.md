---
title: HAProxy Starter Guide翻译
date: 2018-12-02 23:45:17
tags: [HAProxy,翻译]
---

根据[官方18.14文档Starter Guide](https://cbonte.github.io/haproxy-dconv/1.8/intro.html)的翻译，并非完整翻译，且有的地方会有修改。

<!--more-->

* [快速介绍负载均衡和负载均衡器]()
* [HAProxy介绍]()
  * [HAProxy是什么与不是什么]()
  * [HAProxy如何工作]()
  * [基础功能]()
    * [代理]()
    * [SSL]()
    * [监控]()
    * [高可用]()
    * [负载均衡]()
    * [粘性]()
    * [采样和转换信息]()
    * [映射]()
    * [ACL和条件]()
    * [内容转换]()
    * []()
    * []()
    * []()
    * 







# 快速介绍负载均衡和负载均衡器

负载均衡包括聚合多个组件，以便在每个组件的单独流量上实现总处理能力，而无需客户端用户的任何干预并且是可扩展的。这导致组件在仅执行一个操作所花费的时间内同时执行更多操作。 但是，单个操作仍然会一次在单个组件上执行，并且不会比没有负载均衡时更快。 它始终需要至少与可用组件一样多的操作和有效的负载均衡机制来充分利用所有组件并从负载均衡中充分受益。一个很好的例子是高速公路上的车道数量，不增加车辆速度而允许尽可能多的车辆在同一时间段内通过。

负载均衡的示例：

* 多处理器系统中的进程调度
* 链路负载均衡（例如EtherChannel，Bonding）
* IP地址负载均衡（例如ECMP，DNS round-robin）
* 服务器负载均衡（通过负载均衡器）

执行负载均衡操作的机制或组件称为负载均衡器。 在Web环境中，这些组件称为“网络负载均衡器”，更常见的是“负载均衡器”，因为此说法是迄今为止负载均衡的最好示例。

负载均衡器可以起作用：

* 在链路级别：这称为链路负载均衡，它包括选择发送数据包的网络链路
* 在网络级别：这称为网络负载均衡，它包括选择一系列数据包将使用的路由
* 在服务器级别：这称为服务器负载均衡，它包括决定哪个服务器将处理连接或请求

存在两种不同的技术并满足不同的需求，但有一些重叠。在每种情况下，重要的是要记住，负载均衡包括将流量从其自然流转移，并且这样做总是需要最少的维护，以维持所有路由决策之间所需的一致性水平。

第一个技术作用于数据包级别并且或多或少地单独处理数据包。 输入和输出数据包之间存在一对一的关系，因此可以使用常规网络嗅探器跟踪负载均衡器两侧的流量。这项技术非常便宜且速度极快。 它通常以硬件（ASIC）实现，能够达到线速（line rate），例如执行ECMP的交换机。 通常是无状态的，它也可以是有状态的（考虑一个数据包所属的会话并称为layer4-LB或L4），如果数据包没有被修改，可以支持DSR（直接服务器返回，不再通过LB），但几乎不提供内容感知（content awareness）。 该技术非常适合网络级负载均衡，但有时用于高速的基本服务器负载均衡。

第二个技术作用于会话内容。 它要求输入流作为一个整体进行重组和处理。 可以修改内容，并且将输出流分段为新分组。出于这个原因，它通常由代理执行，它们通常被称为第7层负载均衡器或L7。这意味着每一侧有两个不同的连接，并且输入和输出数据包大小与计数之间没有关系。客户端和服务器不需要使用相同的协议（例如IPv4与IPv6，不加密与SSL）。 操作始终是有状态的，返回流量必须通过负载均衡器。 额外的处理带来了成本，因此并不总是能够实现线速，特别是对于小数据包。 另一方面，它提供了广泛的可能性，并且通常通过纯软件实现，即使嵌入到硬件设备中也是如此。 该技术非常适合服务器负载均衡。

基于数据包的负载均衡器通常以直通模式（cut-though mode）部署，因此它们安装在流量的正常路径上，并根据配置进行转移。 返回的流量不一定通过负载均衡器。 可以对网络目的地址进行一些修改，以便将流量引导到适当的目的地。 在这种情况下，返回流量必须通过负载均衡器。如果路由不能实现这一点，则负载均衡器也可以用自己的路由替换数据包的源地址，强制返回流量通过它。

基于代理的负载均衡器部署为具有自己的IP地址和端口的服务器，无需更改体系结构。 
有时，这需要对应用程序执行一些调整，以便客户端正确定向到负载均衡器的IP地址，而不是直接定向到服务器。某些负载均衡器可能必须调整某些服务器的响应才能实现这一点（例如HTTP重定向中使用的HTTP Location头字段）。某些基于代理的负载均衡器可能会拦截其不拥有的地址的流量，并在连接到服务器时欺骗客户端的地址。这使得它们可以像通常的路由器或防火墙一样进行部署，采用与基于数据包的负载均衡器非常相似的直通模式。对于结合了分组模式和代理模式的产品，这是特别受欢迎的。 在这种情况下，DSR显然仍然不可能，并且返回流量仍然必须路由回负载均衡器。

一种非常可扩展的分层方法将包括具有从多个负载均衡链路接收流量的前端路由器，并使用ECMP将该流量分配到多个有状态分组的负载均衡器（L4）的第一层。这些L4负载均衡器又将流量传递给更大数量的基于代理的负载均衡器（L7），这些负载均衡器必须解析内容以确定哪个服务器最终将接收流量。

流量的组件数量和可能的路径增加了失败的风险; 在非常大的环境中，永久性地将一些故障部件修复或替换是正常的。 在不了解整个堆栈的运行状况的情况下完成负载均衡会显着降低可用性。 出于这个原因，任何严谨的负载均衡器都将验证它打算提供流量的组件是否仍然存活且可访问，并且它将停止向故障流量提供流量。 这可以使用各种方法实现。

最常见的一种是定期发送探测包以确保组件仍可运行。 这些探测包称为“健康检查”。 它们必须代表要解决的失败类型。 例如，基于ping的检查不会检测到Web服务器已经崩溃并且不再监听端口，而与端口的连接将验证这一点，而更高级的请求甚至可以验证服务器是否仍然有效并且它依赖的数据库仍然可以访问。 健康检查通常需要进行一些重试以防止偶尔的监测错误。检查之间的时间间隔必须足够小，以确保在发生错误后故障组件的使用时间不会太长。

其他方法包括对发送到目的地的生产流量进行抽样，以观察是否正确处理，并去除返回不适当响应的组件。 然而，这需要牺牲一部分生产流量，这并不总是可以接受的。 这两种机制的组合提供了两全其美的优势，两者都用于检测故障，只有健康检查才能检测到故障的结束。 最后一种方法涉及集中报告：中央监控代理定期更新所有负载均衡器的所有组件的状态。 这为所有组件提供了基础架构的全局视图，但有时精度或响应性较低。 它最适合具有许多负载均衡器和许多服务器的环境。

第7层负载均衡器还面临另一个被称为粘性或持久性的挑战。 原则是它们通常必须将来自同一来源（例如最终用户）的多个后续请求或连接指向同一目标。 最着名的例子是在线商店的购物车。 如果每次点击都会导致新连接，则必须始终将用户发送到保存其购物车的服务器。 内容感知使得更容易发现请求中的某些元素以识别要将其传递到的服务器，但这并不总是足够的。 例如，如果把源地址用作选择服务器的指标，则可以确定将使用基于散列的算法，并且将始终按可用服务器的数量基于地址划分将给定的IP地址发送到同一服务器 。 但是如果一台服务器出现故障，结果会发生变化，所有用户都会突然被发送到另一台服务器并丢失购物车。 针对此问题的解决方案在于记录所选目标，以便每次看到相同的访问者时，无论可用服务器的数量如何，都会将其定向到同一服务器。 信息可以存储在负载均衡器的内存中，在这种情况下，如果不是单独的话，可能必须将其复制到其他负载均衡器，或者可以使用各种方法存储在客户端的内存中，前提是客户端能够随每个请求呈现该信息（cookie插入，重定向到子域等）。 这种机制提供了额外的好处，即不必依赖不稳定或分布不均匀的信息（例如源IP地址）。 事实上，这是采用第7层负载均衡器而不是第4层负载均衡器的最有力理由。

为了提取诸如cookie，主机头字段，URL或其他信息之类的信息，负载均衡器可能需要解密SSL/TLS流量，甚至可能在将其传递给服务器时对其进行重新加密。 这个复杂的任务解释了为什么在一些高流量的基础设施中，有时可能会有很多负载均衡器。 
由于第7层负载均衡器可以对流量执行许多复杂的操作（解密，解析，修改，匹配cookie，决定要发送到哪个服务器等），它肯定会造成一些麻烦，并且通常会为显露出很多麻烦而被指责。 通常会发现服务器不稳定并且周期性地停止重启，或者对于Web服务器，它们会传递带有一些硬编码链接的页面，迫使客户端直接连接到一个特定的服务器而不通过负载均衡器，或者他们需要很长时间才能在高负荷下做出反应，导致超时，这就是为什么日志记录是第7层负载均衡的一个极其重要的方面。一旦报告故障，重要的是要确定负载均衡器是否做出了错误的决定，如果是这样，如何才能不再发生这种情况。



# HAProxy介绍

HAProxy写作“HAProxy”来指定产品，而“haproxy”被指定为可执行程序，软件包或进程。 然而，两者通常用于两种目的，并且发音为H-A-Proxy。，很早以前，“haproxy”曾经代表“高可用性代理”，这个名字用两个单独的单词写成，但现在它只不过是“HAProxy”。



## HAProxy是什么与不是什么

HAProxy是：

* TCP代理：它可以接受来自侦听套接字的TCP连接，连接到服务器并将这些套接字连接在一起，允许流量在两个方向上流动
* HTTP反向代理（在HTTP术语中称为“网关”）：它将自身表示为服务器，通过侦听TCP套接字上接受的连接接收HTTP请求，并使用不同的连接将请求从这些连接传递到服务器。
* SSL终端/发起者/卸载程序（offloader）：SSL / TLS可用于来自客户端，到服务器的连接，甚至两个连接的连接。
* TCP规范化程序（normalizer）：由于操作系统本地终止了连接，双方之间没有关系，因此无效数据包、标志组合、窗口通告（window advertisement）、序列号、不完整连接（SYN泛洪）等异常流量不会被传递到另一边。 这可以保护脆弱的TCP栈免受协议攻击，并且还允许与客户端优化连接参数，而无需修改服务器的TCP栈设置。
* HTTP规范化程序：配置为处理HTTP流量时，仅传递有效的完整请求。 这可以防止许多基于协议的攻击。 另外，规范中存在容差的协议偏差是固定的，因此它们不会在服务器上引起问题（例如，多行头）。
* HTTP修复工具：它可以修改/修复/添加/删除/重写URL或任何请求或响应头。 这有助于解决复杂环境中的互操作性（interoperability）问题。
* 基于内容的交换机：它可以根据请求中的任何元素来决定将请求或连接传递给哪个服务器。 因此，可以在同一端口上处理多个协议（例如，HTTP，HTTPS，SSH）。
* 服务器负载均衡器：它可以对TCP连接和HTTP请求进行负载均衡。 在TCP模式下，对整个连接采取负载均衡决策。 在HTTP模式下，根据请求做出决定。
* 流量调节器：它可以在不同点应用一些速率限制，保护服务器免受过载，根据内容调整流量优先级，甚至通过标记数据包将这些信息传递给较低层和外部网络组件。
* 防止DDoS和服务滥用（service abuse）：它可以维护每个IP地址，URL，cookie等的大量统计信息，并检测何时发生滥用，然后采取措施（减慢违规行为，阻止它们，将它们发送到过时的内容 等）。
* 网络故障排除的观察点：由于日志中报告的信息的精确性，它通常用于缩小网络相关问题的范围。
* HTTP压缩卸载程序：它可以压缩未被服务器压缩的响应，从而减少连接不良或使用高延迟移动网络的客户端的页面加载时间。

HAProxy不是：

* 显式HTTP代理，即浏览器用于访问互联网的代理。 有专门用于此任务的优秀开源软件，例如Squid。 但是，HAProxy可以部署在这样的代理之前，以提供负载平衡和高可用性。
* 缓存代理：它将按原样返回从服务器收到的内容，不会干扰任何缓存策略。 有很好的开源软件可以完成这项任务，比如Varnish。  HAProxy可以部署在这样的缓存之前，通过智能负载平衡提供SSL卸载和可扩展性。
* 数据清理程序：它不会修改请求体和响应体。
* Web服务器：在启动期间，它将自己隔离在chroot jail中并删除其权限，以便一旦启动它就不会执行任何单个文件系统访问。 因此，它无法转变为Web服务器。 有很好的开源软件，如Apache或Nginx，HAProxy可以部署在它们前端，以提供负载平衡和高可用性。
* 基于数据包的负载均衡器：它不会看到IP数据包也不会看到UDP数据包，也不会执行NAT甚至更少的DSR（动态源路由协议）。 这些是较低层的任务。 一些基于内核的组件（如IPVS（Linux虚拟服务器））已经很好地完成了这项工作并与HAProxy完美匹配。



## HAProxy如何工作

HAProxy是一个单线程，事件驱动的非阻塞引擎，它将非常快的I / O层与基于优先级的调度程序相结合。 由于它的设计考虑了数据转发目标，因此其架构经过优化，可以尽可能快地以尽可能少的操作移动数据。 因此，它实现了一个分层模型，在每个级别提供旁路机制（bypass mechanisms），确保数据不会达到更高级别，除非需要。 大多数处理都是在内核中执行的，HAProxy尽最大努力通过提供一些提示或者在猜测它们可以在以后分组时避免某些操作来尽可能快地帮助内核完成工作。 因此，典型数据显示，在TCP或HTTP关闭模式下，HAProxy中花费的处理时间占15％，而在内核占85％，在HTTP keep-alive模式下，HAProxy约占30％，而内核占70％。

单个进程可以运行许多代理实例。根据试验，单个进程中大到300000个不同代理的配置运行正常。 因此，通常不需要为所有实例启动多个进程。 

可以使HAProxy在多个进程上运行，但它有一些限制。 一般来说，它在HTTP关闭或TCP模式下没有意义，因为内核端不能很好地扩展一些操作，如`connect()`。 它可以很好地扩展到HTTP的keep-alive模式，但是可以通过单个进程实现的性能通常比常见的需求高出一个数量级。 但是，当用作SSL卸载器（offloader）时，它确实有意义，并且在多进程模式中很好地支持此功能。

HAProxy只需要运行haproxy可执行文件和配置文件。 对于日志记录，强烈建议使用正确配置的syslog守护程序并记录日志轮换。 在启动之前解析配置文件，然后HAProxy尝试绑定所有侦听套接字，并在任何失败时拒绝启动。做到这一点，它就不会运行失败了。 这意味着没有运行时故障，如果它接受启动，它将一直有效，直到它停止。

一旦HAProxy被启动，它会做三件事：

* 处理传入的连接
* 定期检查服务器状态(称为健康检查)
* 与其他haproxy节点交换信息

处理传入连接是迄今为止最复杂的任务，因为它依赖于许多配置可能性，但它可以概括为以下9个步骤：

1. 接受来自属于称为`frontend`的配置实体的侦听套接字的传入连接 ，引用一个或多个侦听地址
2. 将特定于frontend的处理规则应用于这些可能导致阻塞它们，修改某些头或拦截它们以执行某些内部小程序（例如统计页面或CLI）的连接
3. 将这些传入连接传递给另一个表示称为`backend`的服务器池的配置实体，该服务器场包含服务器列表和此服务器池的负载平衡策略
4. 将特定于后端的处理规则应用于这些连接
5. 根据负载均衡策略决定将连接转发到哪个服务器
6. 将特定于后端的处理规则应用于响应数据
7. 将特定于前端的处理规则应用于响应数据
8. 发出日志详细报告发生的事情
9. 在HTTP中，循环回第二步以等待新请求，否则关闭连接

前端和后端有时被认为是半代理，因为它们只看端到端连接的一侧。前端只关心客户端，而后端只关心服务器。  HAProxy还支持完全代理，它们正是前端和后端的联合。 当需要HTTP处理时，配置通常会分为前端和后端，因为它们会打开很多可能性，因为任何前端都可以将连接传递给任何后端。 对于仅使用TCP的代理，使用前端和后端很少提供好处，并且使用完整代理可以使配置更具可读性。



## 基础功能

本节将列举HAProxy实现的许多功能，其中一些功能通常可以从任何现代负载均衡器中获得，其中一些功能是HAProxy架构的直接优势。 更多高级功能将在下一节中详细介绍。



### 代理

代理是通过两个独立连接在客户端和服务器之间传输数据的操作。通过代理和连接管理，HAProxy具有以下基本特性： 

* 为服务器提供干净的连接，以防止客户端出现任何客户端缺陷或攻击
* 监听多个IP地址或端口，甚至端口范围
* 透明：截取任何甚至不属于本地系统的任意IP地址的流量
* 服务器端口不需要与监听端口相关，甚至可以通过固定偏移量（对范围有用）进行转换

- 透明连接：连接服务器时，如果需要会欺骗客户端（或任何其他主机）的IP地址
- 为多站点LB中的服务器提供可靠的返回IP地址
- 借助缓冲区和可能短暂的连接来卸载服务器，以减少它们的并发连接数和内存占用量
- 优化TCP栈（例如SACK），拥塞控制和减少RTT影响
- 支持双方不同的协议系列（例如IPv4 / IPv6 / Unix）
- 超时强制执行：HAProxy支持多级别的超时，具体取决于连接的阶段，因此断开的客户端或服务器或攻击者不能长时间获得资源
- 协议验证：检查HTTP，SSL或有效负载，拒绝无效的协议元素，除非指示无论如何接受它们
- 策略执行：确保只转发允许的内容
- 传入和传出连接都可能仅限于某些网络命名空间（仅限Linux），因此可以轻松构建跨容器，多用户负载平衡器
- PROXY协议将客户端的IP地址呈现给服务器，即使对于非HTTP流量也是如此。这是一个HAProxy扩展，现在被许多第三方产品采用，在撰写本文时至少有以下产品：
  - 客户端：haproxy，stud，stunnel，exaproxy，ELB，squid 
  - 服务器：haproxy，stud，postfix，exim，nginx，squid，node.js，varnish



### SSL

Google的工程师（http://istlsfastyet.com/）认为HAProxy的SSL栈是最具特色的功能之一。 使其相当完整的最常用特性是：

* 基于SNI的多主机，不限制站点数量并专注于性能。 至少有一个部署用于运行50000个域及其各自的证书
* 对通配符证书（wildcard certificates）的支持减少了对许多证书的需求
* 基于证书的客户端身份验证，如果无法提供有效证书，则使用可配置策略。例如，这允许不同的服务器池重新生成客户端证书
* 后端服务器的身份验证确保后端服务器是真正的后端服务器而不是中间人
* 使用后端服务器进行身份验证让后端服务器知道它实际上是连接到它的预期haproxy节点
* TLS NPN和ALPN扩展使得可以可靠地卸载SPDY/HTTP2连接并以明文形式将它们传递给后端服务器
* 当客户端请求证书状态请求时，通过提供内联OCSP响应，OCSP装订（stapling）进一步减少了首页加载时间
* 动态记录大小调整可提供高性能和低延迟，并且当数据包仍处于运行状态时，允许浏览器开始获取新对象，从而显着缩短页面加载时间
* 永久访问所有相关的SSL/TLS层信息，用于日志记录、访问控制、报告等。这些元素可以嵌入到HTTP报头中，甚至可以作为代理协议扩展，这样卸载的服务器就可以获得如果它自己执行SSL终止时会有的所有信息
* 在易受攻击的SSL库上检测、记录和阻止某些已知攻击，例如影响OpenSSL某些版本的Heartbleed攻击

- 支持无状态会话恢复（RFC 5077 TLS故障单扩展）。可以从CLI更新TLS票证，通过频繁翻转（rotate）票证为他们提供实现Perfect Forward Secrecy的方法。



### 监控

HAProxy非常关注可用性。 因此，它关心服务器状态，并将其自身状态报告给其他网络组件：

* 使用每台服务器的参数持续监控服务器的状态。 这确保了服务器的路径可用于常规流量
* 健康检查支持两个滞后（hysteresis）的上下转换，以防止状态振荡
* 可以将检查发送到不同的地址/端口/协议：这样可以轻松检查被视为代表多个服务的单个服务，例如HTTP + HTTPS服务器的HTTPS端口。
* 服务器可以跟踪其他服务器并同时关闭：这可确保托管多个服务的服务器可以原子方式失败，并且不会将任何人发送到部分故障的服务器
* 可以在服务器上部署代理以监视负载和运行状况：服务器可能有兴趣报告其负载，运行状态，管理状态，而不管运行状况检查可以看到什么。 
  通过在服务器上运行一个简单的代理，除了验证整个路径的运行状况检查外，还可以考虑服务器对自身运行状况的看法
* 提供各种检查方法：TCP连接，HTTP请求，SMTP hello，SSL hello，LDAP，SQL，Redis，send / 
  expect脚本，所有有/无SSL
* 状态更改在日志和统计信息页面中以失败原因通知（例如，在检测到故障时收到的HTTP响应）。 
  在发生此类更改时，也可以将电子邮件发送到可配置的地址
* 服务器状态也在统计接口上报告，并且可用于做出路由决定，以便可以根据流量大小和/或健康状况（例如，丢失DC间链路）将流量发送到不同的服务器场。
* HAProxy可以使用运行状况检查请求将信息传递给服务器，例如其名称，重量，服务器场中其他服务器的数量等，以便服务器可以根据这些知识调整其响应和决策（例如，推迟备份以保持
  更多CPU可用）
* 服务器可以使用健康检查报告更详细的状态，而不仅仅是打开/关闭（例如，我想停止，请停止发送新访问者）
* HAProxy本身可以将其状态报告给外部组件，例如路由器或其他负载平衡器，从而可以构建非常完整的多路径和多层基础架构。



### 高可用

就像任何负载均衡器一样，HAProxy非常重视可用性，以确保最佳的全局服务持续性：

* 仅使用有效的服务器，其他的被自动从负载平衡服务器群中剔除，在某些条件下，仍有可能强制使用它们
* 支持优雅关闭，以便可以在不影响任何连接的情况下将服务器从服务器群中剔除
* 当活跃服务器关闭时自动使用备份服务器并替换它们，以便在可能的情况下不会丢失会话。 这还允许构建多个路径以到达相同的服务器（例如，多个接口）
* 当服务器过多时，能够返回服务器群的全局故障状态。 这与监视功能相结合，使上游组件可以为给定的服务选择不同的LB节点
* 无状态设计使构建集群变得容易：通过设计，HAProxy尽最大努力确保最高的服务持续性，而无需存储在发生故障时可能丢失的信息。 这确保了接管是最无缝的。
* 与标准VRRP守护程序保持良好集成：HAProxy告知keepalived其状态，并与浮动虚拟IP地址很好地对应。 注意：仅使用基于集群的解决方案（Heartbeat，...）的IP冗余协议（VRRP/CARP），因为它们是提供最快，最无缝和最可靠切换的解决方案。



### 负载均衡

HAProxy提供了一套相当完整的负载均衡功能，其中大多数功能在许多其他负载平衡产品中是不支持的：

- 支持不少于9种负载均衡算法，其中一些适用于输入数据，以提供无限的可能性列表。 最常见的是round-robin（用于短连接，依次选择每个服务器），leastconn（用于长连接，选择最近最少使用的具有最低连接数的服务器），source（用于SSL服务器群或终端服务器群，服务器直接依赖于客户端的源地址），uri（对于HTTP缓存，服务器直接依赖于HTTP URI），hdr（服务器直接依赖于特定HTTP头字段的内容），first（对于短期虚拟机，所有连接都打包在最小的服务器子集上，以便可以关闭未使用的服务器）
- 以上所有算法都支持服务器权重，以便可以适应服务器群中不同的级别的服务器，或者将一小部分流量引导到特定服务器（调试模式，运行下一版本的软件等）

- 支持动态权重的轮询、最小控制和一致哈希，这允许从CLI动态修改服务器权重，甚至允许服务器上运行的代理修改服务器权重

- 只要支持动态权重，就支持慢启动，这允许服务器逐步获取流量。 这是脆弱的应用程序服务器的一个重要特性，它需要在运行时编译类以及需要在全速运行之前填满的冷缓存（cold caches）

- 散列可以应用于各种元素，如客户端的源地址，URL组件，查询字符串元素，报文头字段值，POST参数，RDP cookie

- 在服务器群中添加或删除服务器时，一致性哈希（consitent hashing）可保护服务器群免受大量重新分发的影响。 这在大型缓存群中非常重要，它允许使用慢启动来重新填充冷缓存

- 许多内部指标，例如每个服务器、每个后端的连接数，后端中可用连接插槽的数量等，可以构建非常先进的负载平衡策略。



### 粘性

如果没有粘性（stickness），应用程序负载平衡将毫无用处。  HAProxy提供了一套相当全面的可能性，可以将访问者维持在同一台服务器上，甚至可以跨越各种事件，例如服务器添加/删除，下线/上线周期，并且某些方法可以克服多个负载平衡节点之间的距离并不需要任何复制：

- 如果需要，粘性信息可以单独匹配并从不同的地方学习。 例如，JSESSIONID cookie可以在cookie和URL中匹配。 可以同时学习多达8个并行源，每个源可以指向不同的绑定表（stick-table）

- 粘性信息可以来自请求或响应中可以看到的任何内容，包括源地址，TCP有效负载偏移和长度，HTTP查询字符串元素，标头字段值，cookie等

- 以多主方式在所有节点之间复制绑定表
- 常用的元素，如SSL-ID或RDP cookie（用于TSE群）可直接访问，以方便操作
- 所有粘性规则都可以由ACL动态调节

- 可以决定不绑定某些服务器，例如备份服务器。这样当名义上的（nominal）服务器返回集群时，它会自动恢复负载。 这通常用于多路径环境

- 在HTTP中，通常不会学习任何东西，而是操纵专用于粘性的cookie。 为此，可以检测，重写，插入或添加这样的cookie，让客户端记住分配了哪个服务器

- 服务器可以决定在注销时更改或清除粘性cookie，以便离开的访问者自动从服务器解除绑定

- 使用基于ACL的规则，无论服务器的状态如何，都可以选择性地忽略或强制粘性，结合高级健康检查，帮助管理员验证他们正在安装的服务器是否正常运行，再对外服务

- 在cookie上设置最大空闲时间（maximum idle time）和持续时间（duration）的机制可确保在永不关闭的设备（智能手机，电视，家用电器）上顺利停止粘性，而无需将其存储在持久存储上

- 多个服务器条目可以共享相同的粘性键，以便在一个路径发生故障时多路径环境中不会丢失粘性
- 软停止（soft-stop）确保只有具有粘性信息的用户才能继续访问他们已被分配到的服务器，但新用户不能被分配到那些服务器



















































































































